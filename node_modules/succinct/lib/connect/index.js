var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var Component = React.Component;
var provider_1 = require("../provider");
var reaction_1 = require("../reaction");
var reactiveMixin = {
    componentWillMount: function () {
        var _this = this;
        var baseRender = this.render.bind(this);
        var reactiveRender = function () {
            var exception = undefined;
            var rendering = undefined;
            _this.$reaction.track(function () {
                try {
                    rendering = baseRender();
                }
                catch (e) {
                    exception = e;
                }
            });
            if (exception) {
                throw exception;
            }
            return rendering;
        };
        this.render = reactiveRender;
    },
    componentWillUnmount: function () {
        this.$reaction && this.$reaction.dispose();
    }
};
function makeSelectorStateful(sourceSelector, store) {
    var selector = {
        shouldComponentUpdate: true,
        props: {},
        error: null,
        run: function runComponentSelector(props) {
            try {
                var nextProps = sourceSelector(store.getState(), props);
                if (nextProps !== selector.props || selector.error) {
                    selector.shouldComponentUpdate = true;
                    selector.props = nextProps;
                    selector.error = null;
                }
            }
            catch (error) {
                selector.shouldComponentUpdate = true;
                selector.error = error;
            }
        }
    };
    return selector;
}
function patch(target, funcName, runMixinFirst) {
    if (runMixinFirst === void 0) { runMixinFirst = false; }
    var base = target[funcName];
    var mixinFunc = reactiveMixin[funcName];
    var f = !base
        ? mixinFunc
        : runMixinFirst === true
            ? function () {
                mixinFunc.apply(this, arguments);
                base.apply(this, arguments);
            }
            : function () {
                base.apply(this, arguments);
                mixinFunc.apply(this, arguments);
            };
    target[funcName] = f;
}
function mixinLifecycleEvents(target) {
    patch(target, "componentWillMount", true);
    patch(target, "componentWillUnmount");
}
function connect(mapStateToProps, options) {
    if (options === void 0) { options = {}; }
    var _a = options.storeKey, storeKey = _a === void 0 ? "store" : _a;
    return function (Target) {
        var ConnectComponent = (function (_super) {
            __extends(ConnectComponent, _super);
            function ConnectComponent(props, context) {
                var _this = _super.call(this, props) || this;
                _this.contextTypes = (_a = {},
                    _a[storeKey] = provider_1.storeShape.isRequired,
                    _a);
                _this.store = props[storeKey] || context[storeKey];
                _this.selector = makeSelectorStateful(mapStateToProps, _this.store);
                _this.selector.run(props);
                _this.$reaction = new reaction_1.default(_this);
                return _this;
                var _a;
            }
            ConnectComponent.prototype.componentWillReceiveProps = function (nextProps) {
                this.selector.run(nextProps);
            };
            ConnectComponent.prototype.shouldComponentUpdate = function () {
                return this.selector.shouldComponentUpdate;
            };
            ConnectComponent.prototype.render = function () {
                var props = this.selector.props;
                return React.createElement(Target, __assign({}, props));
            };
            return ConnectComponent;
        }(React.Component));
        ;
        mixinLifecycleEvents(ConnectComponent.prototype || ConnectComponent);
        // ConnectComponent
        return ConnectComponent;
    };
}
exports.default = connect;
